Ecco una proposta per un nuovo "Esercizio Lode" basato sulla verifica di una matrice, con il vincolo della **ricorsione**, in linea con lo stile degli esami caricati (come quello sulla frazione continua o sui k-mer).

---

###Esame 20260115 - Esercizio Lode**--- PAGE 1 ---**

**Esame 20260115**

**Esercizio lode**

**(1) Esercizio Lode**

**ESSAY marked out of 1 penalty 0 File picker**

In algebra lineare, una **matrice di Toeplitz** è una matrice in cui ogni diagonale discendente da sinistra verso destra è costante.
In termini formali, una matrice quadrata A di dimensione N \times N è di Toeplitz se e solo se:

A_{i,j} = A_{i+1, j+1}

per ogni 0 \le i < N-1 e 0 \le j < N-1.

Ad esempio, la seguente matrice è di Toeplitz:

```text
a b c d
e a b c
f e a b
g f e a

```

Come si può notare, la diagonale principale contiene tutte 'a', la diagonale subito sopra tutte 'b', quella subito sotto tutte 'e', e così via.

Si richiede di implementare nel file `lode.cpp` la funzione **ricorsiva**:

`bool matriceToeplitz(int** mat, int dim, int r, int c);`

La funzione prende in ingresso:

* `mat`: puntatore alla matrice (allocata dinamicamente come array di array).
* `dim`: la dimensione N della matrice quadrata.
* `r`: indice di riga corrente (inizialmente 0).
* `c`: indice di colonna corrente (inizialmente 0).

La funzione deve restituire `true` se la matrice è di Toeplitz, `false` altrimenti.

**Vincoli di implementazione:**

* La funzione **DEVE** essere **ricorsiva**.
* **NON** è ammesso l'uso di cicli (`for`, `while`, `do-while`). L'iterazione attraverso la matrice deve essere gestita tramite le chiamate ricorsive.
* Non è consentito usare variabili globali o statiche.

Il file `lode.cpp` contiene un `main()` già pronto per il test. Di seguito un esempio di esecuzione:

```text
computer > ./a.out
Matrice:
1 2 3
4 1 2
5 4 1
Risultato: TRUE

Matrice:
1 2 3
4 1 5
5 4 1
Risultato: FALSE

```

**Note importanti:**

* Scaricare il file `lode.cpp`.
* Modificare solo inserendo la definizione della funzione richiesta.
* Caricare il file risultante.

**Information for graders:**
Total of marks: 1

---

###Soluzione Proposta (Codice)Ecco come implementare la funzione ricorsiva richiesta. La logica attraversa la matrice cella per cella. Per ogni cella (r, c), controlliamo se il suo vicino sulla diagonale (r+1, c+1) esiste ed è uguale.

```cpp
#include <iostream>
#include <cstdlib>

using namespace std;

// Inserire qui la definizione della funzione
bool matriceToeplitz(int** mat, int dim, int r, int c) {
    // CASO BASE 1: Se siamo arrivati all'ultima riga, non ci sono
    // elementi successivi in diagonale (r+1) da controllare.
    // Abbiamo controllato tutto con successo.
    if (r >= dim - 1) {
        return true;
    }

    // CONTROLLO TOEPLITZ:
    // Se non siamo sull'ultima colonna, possiamo controllare il valore diagonale.
    // La condizione è A[r][c] == A[r+1][c+1]
    if (c < dim - 1) {
        if (mat[r][c] != mat[r+1][c+1]) {
            return false;
        }
    }

    // PASSO RICORSIVO (Navigazione della matrice):
    // Dobbiamo spostarci alla prossima cella.
    
    // Se siamo all'ultima colonna, passiamo alla riga successiva, colonna 0
    if (c == dim - 1) {
        return matriceToeplitz(mat, dim, r + 1, 0);
    } 
    // Altrimenti passiamo alla colonna successiva nella stessa riga
    else {
        return matriceToeplitz(mat, dim, r, c + 1);
    }
}

// -----------------------------------------------------
// MAIN DI ESEMPIO (Simulazione del file lode.cpp fornito)
// -----------------------------------------------------
int main() {
    int dim = 3;
    
    // Allocazione matrice di prova
    int** mat = new int*[dim];
    for(int i=0; i<dim; i++) mat[i] = new int[dim];

    // Test 1: Toeplitz
    // 1 2 3
    // 4 1 2
    // 5 4 1
    mat[0][0]=1; mat[0][1]=2; mat[0][2]=3;
    mat[1][0]=4; mat[1][1]=1; mat[1][2]=2;
    mat[2][0]=5; mat[2][1]=4; mat[2][2]=1;

    cout << "Test 1 (Atteso 1): " << matriceToeplitz(mat, dim, 0, 0) << endl;

    // Test 2: Non Toeplitz
    mat[1][2] = 9; // Rompe la diagonale del 2
    cout << "Test 2 (Atteso 0): " << matriceToeplitz(mat, dim, 0, 0) << endl;

    // Deallocazione
    for(int i=0; i<dim; i++) delete[] mat[i];
    delete[] mat;

    return 0;
}

```

###Spiegazione della logica ricorsiva1. **Navigazione**: La funzione simula due cicli annidati. Gli indici `r` (riga) e `c` (colonna) vengono incrementati nelle chiamate ricorsive. Quando `c` raggiunge la fine della riga (`dim - 1`), la ricorsione passa a `r + 1` e resetta `c` a 0.
2. **Controllo**: Invece di controllare intere diagonali alla volta, controlliamo localmente: "Il mio valore è uguale a quello del mio vicino in basso a destra?". Se è vero per ogni cella (escluse quelle dell'ultima riga e ultima colonna che non hanno vicini in basso a destra), allora la matrice è di Toeplitz.
3. **Terminazione**:
* Se troviamo una discrepanza (`mat[r][c] != mat[r+1][c+1]`), ritorniamo subito `false`.
* Se arriviamo all'ultima riga (`r == dim - 1`), non ci sono più controlli da fare verso il basso, quindi ritorniamo `true` (successo).

