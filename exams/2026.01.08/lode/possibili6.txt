Ok, te ne preparo uno bello ‚Äúda lode‚Äù, nello stesso stile di quelli che hai gi√† (Gray code, Huffman, BST, ecc.), con albero binario e ricorsione.

---

# Esame 2026XXXX

## Esercizio Lode ‚Äì **Diametro di un albero binario**

ATTENZIONE: Questo esercizio consente di conseguire la lode e viene valutato **se e solo se** tutti gli altri esercizi sono stati svolti correttamente.

In molti contesti (reti di comunicazione, strutture gerarchiche, modelli ad albero), √® utile calcolare la ‚Äúdistanza massima‚Äù tra due nodi di un albero.

Dato un **albero binario** (non necessariamente di ricerca), il **diametro** dell‚Äôalbero √® definito come il **numero massimo di nodi** presenti in un qualsiasi cammino semplice tra due nodi dell‚Äôalbero.

Esempi:

* Albero composto da un solo nodo:
  diametro = 1 (il cammino √® solo quel nodo).
* Albero:

  ```
      5
     / \
    3   8
   / \
  1   4
  ```

  Un cammino massimo √®: `1 ‚Üí 3 ‚Üí 4` oppure `1 ‚Üí 3 ‚Üí 5 ‚Üí 8` (il pi√π lungo √® il secondo),
  quindi il diametro √® 4.

Si supponga di avere un file `tree.h` che definisce la struttura:

```cpp
struct Node {
    int value;
    Node* left;
    Node* right;
};
```

e che contenga funzioni di supporto per creare e stampare un albero, gi√† utilizzate nel `main` del file `lode.cpp`.

---

## Obiettivo

Completare il programma `lode.cpp` inserendo la **dichiarazione e la definizione** della funzione:

```cpp
int diametro(Node* root);
```

che, dato un puntatore alla radice `root` di un albero binario, restituisce il **diametro** dell‚Äôalbero, cio√® il numero massimo di nodi su un cammino semplice tra due nodi qualunque dell‚Äôalbero.

Si assuma che:

* un albero vuoto (`root == nullptr`) abbia diametro 0;
* un albero con un solo nodo abbia diametro 1.

Il `main` (gi√† fornito e da **non modificare**) si occupa di:

1. costruire uno o pi√π alberi di esempio,
2. chiamare la funzione `diametro` su ciascun albero,
3. stampare il risultato.

---

## Suggerimento (non obbligatorio)

Un possibile approccio ricorsivo consiste nell‚Äôusare una funzione ausiliaria che, per ogni nodo:

* calcola l‚Äô**altezza** del sottoalbero radicato in quel nodo,
* aggiorna una variabile (passata per riferimento) che mantiene il **miglior diametro** trovato finora.

Per un nodo `x`:

* `h_sx` = altezza del sottoalbero sinistro,
* `h_dx` = altezza del sottoalbero destro,

un cammino massimo che **passa per `x`** ha lunghezza:

```text
h_sx + h_dx + 1   (in numero di nodi)
```

Il diametro globale √® il massimo, tra tutti i nodi, di questa quantit√†.

---

## Vincoli

* √à **obbligatorio** utilizzare un approccio **ricorsivo** per il calcolo (direttamente in `diametro` o tramite una/e funzione/i ausiliaria/e).
* Non √® consentito utilizzare **variabili globali** o di tipo `static`.
* Sono consentite solo le librerie standard gi√† incluse nel file (`iostream`, ed eventualmente altre indicate).
* Il file `lode.cpp` deve essere modificato **solo** per:

  * inserire la dichiarazione e definizione di `diametro`,
  * e di eventuali funzioni ausiliarie strettamente necessarie.
* Il `main` e gli altri file (`tree.h`, eventuali `tree.cpp`) **non devono essere modificati** (pena annullamento dell‚Äôesercizio).

---

## Esempio (a scopo illustrativo)

Se il programma costruisce l‚Äôalbero:

```text
      5
     / \
    3   8
   / \
  1   4
```

l‚Äôoutput potrebbe essere:

```text
Diametro dell‚Äôalbero: 4
```

---

Se vuoi, nel prossimo messaggio posso anche scriverti **la soluzione completa** (implementazione di `diametro` con la funzione ausiliaria per altezza+diametro) pronta da incollare.

Perfetto, ecco una soluzione completa e ‚Äúda esame‚Äù per il problema del **diametro dell‚Äôalbero binario**, senza variabili globali e con approccio ricorsivo.

Assumo che in `tree.h` tu abbia qualcosa tipo:

```cpp
struct Node {
    int value;
    Node* left;
    Node* right;
};
```

Tu devi solo aggiungere queste funzioni in `lode.cpp` (senza toccare il `main`).

---

## üîß Soluzione: `diametro` + funzione ausiliaria

```cpp
// Funzione ausiliaria ricorsiva che calcola l'altezza del sottoalbero
// radicato in 'node' e, tramite il riferimento 'bestDiam',
// aggiorna il diametro massimo trovato finora.
//
// Ritorna: altezza del sottoalbero (in numero di nodi).
int altezzaConDiametro(Node* node, int &bestDiam) {
    if (node == nullptr) {
        // Altezza di un albero vuoto = 0
        return 0;
    }

    // Altezza del sottoalbero sinistro
    int h_sx = altezzaConDiametro(node->left, bestDiam);
    // Altezza del sottoalbero destro
    int h_dx = altezzaConDiametro(node->right, bestDiam);

    // Il cammino massimo che passa per questo nodo (in numero di nodi)
    int camminoPassaQui = h_sx + h_dx + 1;

    // Aggiorna il diametro migliore
    if (camminoPassaQui > bestDiam) {
        bestDiam = camminoPassaQui;
    }

    // Altezza di questo sottoalbero = 1 + max(h_sx, h_dx)
    int max_h = (h_sx > h_dx) ? h_sx : h_dx;
    return max_h + 1;
}

// Funzione principale richiesta dall'esercizio
int diametro(Node* root) {
    if (root == nullptr) {
        // Albero vuoto: diametro 0
        return 0;
    }

    int bestDiam = 0;
    altezzaConDiametro(root, bestDiam);
    return bestDiam;
}
```

### Com‚Äô√® fatta la soluzione

* `diametro(root)`:

  * se l‚Äôalbero √® vuoto ‚Üí `0`;
  * altrimenti crea una variabile locale `bestDiam`, chiama la ricorsiva `altezzaConDiametro` e alla fine restituisce `bestDiam`.

* `altezzaConDiametro(node, bestDiam)`:

  * restituisce l‚Äô**altezza** del sottoalbero di `node`;
  * ogni volta che ‚Äútorna su‚Äù da sinistra e destra:

    * calcola `camminoPassaQui = h_sx + h_dx + 1`;
    * aggiorna `bestDiam` se questo cammino √® pi√π lungo del massimo trovato finora.

Nessuna variabile globale, solo passaggio per riferimento üëç

Se vuoi, nel prossimo messaggio posso anche buttarti gi√π un piccolo `main` di test separato per provarla in un progettino a parte.

